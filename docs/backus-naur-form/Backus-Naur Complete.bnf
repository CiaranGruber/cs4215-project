# ------------------------ Function definition ------------------------

<translation-unit> ::= <external-declaration>
                     | <translation-unit> <external-declaration>

<external-declaration> ::= <function-definition>
                         | <declaration>

# In other words - Declaration specifiers is type, declarator is name and params, declaration list is x and compound
# statement is the main body
<function-definition> ::= <declaration-specifiers> <declarator> {<declaration-list>}? <compound-statement>

# ------------------------ Statements ------------------------

# Labelled statements - used for goto and other things
<labelled-statement> ::= <identifier> : <statement>
                      | case <constant-expression> : <statement>
                      | default : <statement>

# Block statements
<compound-statement> ::= { {<block-item-list>}? }

<block-item-list> ::= <block-item>
                    | <block-item-list> <block-item>

<block-item> ::= <declaration>
               | <statement>

# Standard expression statement
<expression-statement> ::= {<expression>}? ;

# Selection statement
<selection-statement> ::= if ( <expression> ) <statement>
                        | if ( <expression> ) <statement> else <statement>
                        | switch ( <expression> ) <statement>

# Iteration statements
<iteration-statement> ::= while ( <expression> ) <statement>
                        | do ( <statement> ) while ( <expression> ) ;
                        | for ( {<expression>}? ; {<expression>}? ; {<expression>}? ) <statement>
                        | for ( <declaration> {<expression>}? ; {<expression>}? ) <statement> # Standard for loop (uses declaration)

# Jump statements
<jump-statement> ::= goto <identifier> ;  # Goes to a label within the enclosing function
                   | continue ;
                   | break ;
                   | return {<expression>}? ;

# ------------------------ Initialisers ------------------------

<initialiser> ::= <assignment-expression> # An expression to initialise to
                | { <initialiser-list> } # Used for initialising arrays and structs
                | { <initialiser-list> , } # The initialiser list with a trailing comma

<initialiser-list> ::= {<designation>}? <initialiser>
                     | <initialiser-list>, {<designation>}? <initialiser>

<designation> ::= <designator-list> =

<designator-list> ::= <designator> # Single designator
                    | <designator-list> <designator> # Used for multi-dimensional array, etc

<designator> ::= [ <constant-expression> ] # Value has array type
               | . <identifier> # Value is a structure or union

# Allows for the initialisation of multiple values of the same type. Eg. int x = 2, y = 3;
<init-declarator-list> ::= <init-declarator>
                         | <init-declarator-list> , <init-declarator>

# Describes the standard way to initialise a value
<init-declarator> ::= <declarator>
                    | <declarator> = <initialiser>

# ------------------------ Declarations ------------------------
# Used when referencing an existing variable, etc

<declarator-list> ::= <declaration>
                    | <declaration-list> <declaration>

# Contains a set of specifiers and the initialiser
<declaration> ::= <declaration-specifiers> {<init-declarator-list>}? ;

# Creates a set of declaration specifiers
<declaration-specifiers> ::= <storage-class-specifier> {<declaration-specifiers>}?
                           | <type-specifier> {<declaration-specifiers>}?
                           | <type-qualfier> {<declaration-specifiers>}?
                           | <function-specifier> {<declaration-specifiers>}?

# A decorated name/identifier
<declarator> ::= {<pointer>}? <direct-declarator>

# Decorates an identifier with the relevant parts
<direct-declarator> ::= <identifier> # Identifier by itself - base version
                      | ( <declarator> ) # Is identical to unparenthesised although binding may be altered
                      | <direct-declarator> [ {<type-qualifier-list>}? {<assignment-expression>}? ] # Array declaration with expression
                      | <direct-declarator> [ static {<type-qualifier-list>}? <assignment-expression> ] # Array declaration with static type
                      | <direct-declarator> [ <type-qualifier-list> static <assignment-expression> ] # Array declaration with static expression
                      | <direct-declarator> [ <type-qualifier-list> * ] # Variable-length array - only used within declarations of functions
                      | <direct-declarator> ( <parameter-type-list> ) # Used for defining functions
                      | <direct-declarator> ( {<identifier-list>}? ) # 

<pointer> ::= * {<type-qualifier-list>}?
            | * {<type-qualifier-list>}? <pointer>

<parameter-type-list> ::= <parameter-list> # Used for standard parameter list
                        | <parameter-list> , ... # Used for functions with and unspecified argument value at the end 

# Standard list of parameters
<parameter-list> ::= <parameter-declaration>
                   | <parameter-list> , <parameter-declaration>

# Parameters
<parameter-declaration> ::= <declaration-specifiers> <declarator>
                          | <declaration-specifiers> {<abstract-declarator>}? # Used for function prototypes

# Declares the variable types without need for an identifier
<abstract-declarator> ::= <pointer>
                        | {<pointer>}? <direct-abstract-declarator>

<direct-abstract-declarator> ::= ( <abstract-declarator> )
                               | <direct-abstract-declarator> [ {<type-qualifier-list>}? {<assignment-expression>}? ] # Array declaration with expression
                               | <direct-abstract-declarator> [ static {<type-qualifier-list>}? <assignment-expression> ] # Array declaration with static type
                               | <direct-abstract-declarator> [ <type-qualifier-list> static <assignment-expression> ] # Array declaration with static expression
                               | <direct-abstract-declarator> [ <type-qualifier-list> * ] # Variable length array - only used within declarations of functions
                               | <direct-abstract-declarator> ( <parameter-type-list> ) # Used for defining functions

<typedef-name> ::= <identifier>

# ------------------------ Type specification ------------------------
# These specify the actual type

# Specifies the way that types are to be stored
<storage-class-specifier> ::= typedef # Defines a new type
                            | extern # Specifies that it is already defined elsewhere in the program (but not in the current file)
                            | static # Retains the value within statically allocated memory rather than dynamic memory
                            | auto # Does nothing
                            | register # Access to the object should be as fast as possible

# Specifies the actual types of values
<type-specifier> ::= void
                   | char
                   | short
                   | int
                   | long
                   | float
                   | double
                   | signed
                   | unsigned
                   | _Bool
                   | <struct-or-union-specifier>
                   | <enum-specifier>
                   | <typedef-name>

<type-qualifier-list> ::= <type-qualifier>
                        | <type-qualifier-list> <type-qualifier>

# Specifies what to do when setting values
<type-qualifier> ::= const # Specifies that the thing to the right will not change
                   | volatile # Specifies that variables must be read from memory every time

# Specifies a type name
<type-name> ::= <specifier-qualifier-list> {<abstract-declarator>}?

# Combines a set of type qualifiers and type specifiers
<specifier-qualifier-list> ::= <type-specifier> {<specifier-qualifier-list>}?
                             | <type-qualifier> {<specifier-qualifier-list>}?

# ------------------------ Function specification ------------------------

# Refines a function further
<function-specifier> ::= inline # Used if the function only contains a return (equivalent of a tail call)

# ------------------------ Struct and Union specification ------------------------

# Declares a structure or union
<struct-or-union-specifier> ::= <struct-or-union> <identifier> { <struct-declaration-list> } # Declares and defines a struct with an identifier
                              | <struct-or-union> { <struct-declaration-list> } # Defines an anonymous struct 
                              | <struct-or-union> <identifier> # Declares the struct without defining it

# Defines a list of attributes within the struct
<struct-declaration-list> ::= <struct-declaration>
                            | <struct-declaration-list> <struct-declaration>

# Defines an attribute in the struct (Note: Can be a list of values or just a qualified type)
<struct-declaration> ::= <specifier-qualifier-list> {<struct-declarator-list>}? ;

# Contains a list of names with the same type
<struct-declarator-list> ::= {<struct-declarator-list> ,}? <struct-declarator>

# Used to declare values in a struct
<struct-declarator> ::= <declarator> # Used for anonymous values
                      | {<declarator>}? : <constant-expression> # Used for default values

# The actual struct or union keywords
<struct-or-union> ::= struct
                    | union

# ------------------------ Enum specification ------------------------

# Declares an enumeration
<enum-specifier> ::= enum {<identifier>}? { <enumerator-list> } # Declares and defines an enumeration
                   | enum {<identifier>}? { <enumerator-list> , } # Declares and defines an enumeration with a spare comma
                   | enum <identifier> # Declares an enumeration without defining it

# Defines a list of enumerators
<enumerator-list> ::= <enumerator>
                    | <enumerator-list> , <enumerator>

# Defines an enumeration constant
<enumerator> ::= <enumeration-constant> # Defines an enumeration constant without a value
               | <enumeration-constant> = <constant-expression> # Defines an enumeration constant with a value

# ------------------------ Expressions ------------------------
# These are things that return a value

# Can be calculated at compile-time for improved optimisation.
# Must not contain assignment, increment, decrement, function-call, or comma operators
<constant-expression> ::= <conditional-expression>

# The base type of expression (excluding comma-expression)
<expression> ::= <comma-expression>

# This evaluates the first value and then returns the second value. For example (t=2, t+2) will return 4 if t is declared
<comma-expression> ::= <assignment-expression>
                     | <expression> , <assignment-expression>

# Assigns a value and returns the set value
# Note: <unary-expression> must be a modifiable lvalue
<assignment-expression> ::= <conditional-expression>
                          | <unary-expression> = <assignment-expression>
                          | <unary-expression> <assignment-operator-shorthand> <assignment-expression>

# Each operator can be converted from 'E1 op E2' to 'E1 = E1 op E2'
<assignment-operator-shorthand> ::= *=
                                  | /=
                                  | %=
                                  | +=
                                  | <<=
                                  | >>=
                                  | &=
                                  | ^=
                                  | |=

# Runs conditional expressions returns <expression> if <logical-or-expression> is true, else <conditional-expression>
# Note: The way its set prevents the following: true ? 1 : a = 2;
# Additionally, this will always return a value. It cannot return an lvalue
<conditional-expression> ::= <logical-or-expression>
                           | <logical-or-expression> ? <expression> : <conditional-expression>

# Performs logical or on both values
<logical-or-expression> ::= <logical-and-expression>
                          | <logical-or-expression> && <logical-and-expression>

# Performs logical and on both values
<logical-and-expression> ::= <inclusive-or-expression>
                           | <logical-and-expression> && <inclusive-or-expression>

# Performs bitwise inclusive or on two values
<inclusive-or-expression> ::= <exclusive-or-expression>
                            | <inclusive-or-expression> | <exclusive-or-expression> 

# Performs bitwise exclusive or on two values
<exclusive-or-expression> ::= <and-expression>
                            | <exclusive-or-expression> ^ <and-expression> 

# Performs bitwise AND on two values
<and-expression> ::= <equality-expression>
                   | <and-expression> & <equality-expression>

# This is equality testing
<equality-expression> ::= <relational-expression>
                        | <equality-expression> <equality-operators> <relational-expression>

<equality-operators> ::= == # Tests equality
                       | != # Tests inequality

# This is basically greater than or less than
<relational-expression> ::= <shift-expression>
                          | <relational-expression> <relational-operators> <shift-expression>

<relational-operators> ::= >
                         | <
                         | >=
                         | <=

# These are the bitwise shift operators
<shift-expression> ::= <additive-expression>
                     | <shift-expression> <shift-operators> <additive-expression> # Shifts the first value by the second value

<shift-operators> ::= >> # Shifts right
                    | << # Shifts left

# These are the additive operators
<additive-expression> ::= <multiplicative-expression>
                        | <additive-expression> <additive-operators> <multiplicative-expression>

<additive-operators> ::= +
                       | -

# Runs multiplicative operations from left to right
<multiplicative-expression> ::= <cast-expression>
                              | <multiplicative-expression> <multiplicative-operators> <cast-expression>

<multiplicative-operators> ::= *
                             | /
                             | %

<cast-expression> ::= <unary-expression>
                    | <cast-expression> # Casts the value to the given type

<unary-expression> ::= <postfix-expression>
                     | ++ <unary-expression> # Increments value and returns incremented lvalue (++E1 = E += 1)
                     | -- <unary-expression> # Decrements value and returns incremented lvalue (--E1 = E -= 1)
                     | <unary-operator> <cast-expression> # Runs the various operators on the given expression. Note allows - (int) a
                     | sizeof <unary-expression> # Allows sizeof to work without needing function. Note 'sizeofa' must not compile
                     | sizeof ( <type-name> ) # Returns the size in bytes of a type (Note: sizeof(a) where a is a variable is solved
                                              # by primary-expression)

<unary-operator> ::= & # Gets the reference of the lvalue
                   | * # Dereferences a given lvalue
                   | + # Does nothing
                   | - # Flips the sign of the given value
                   | ~ # Flips the individual bits for the value
                   | ! # Flips a boolean value

<postfix-expression> ::= <primary-expression>
                       | <postfix-expression> [ <expression> ]  # Access an array element (E1[E2] = *(E1+E2))
                       | <postfix-expression> ( ) # Evaluate function without params
                       | <postfix-expression> ( <argument-expression-list> ) # Evaluate function with params
                       | <postfix-expression> . <identifier> # Gets a value in a struct
                       | <postfix-expression> -> <identifier> # Dereferences a struct and gets the value (E1->E2 = (*E1).E2)
                       | <postfix-expression> ++ # Increments value but returns original
                       | <postfix-expression> -- # Decrements value but returns original

<primary-expression> ::= <identifier>
                       | <constant>
                       | <string>
                       | ( <expression> ) # Requires anything of greater hierarchy to be wrapped in brackets (Ie. can't have ++ (int) a)

# ------------------------ Miscellaneous ------------------------

# A list of identifiers
<identifier-list> ::= <identifier>
                    | <identifier-list> , <identifier>

# These are the variable names
<identifier> ::= <letter> {<alpha-num>}*

# ------------------------ Constants ------------------------
# These are the available constants and their definitions
# They are typically built of types of symbols

<constant> ::= <integer-constant>
             | <character-constant>
             | <floating-constant>

<string> ::= " {<alpha-num>}* "

<character-constant> ::= ' <alpha-num> '

<integer-constant> ::= <signed-integer>
                     | <unsigned-integer>

<floating-constant> ::= <integer> . <unsigned-integer>

<signed-integer> ::= <sign> <unsigned-integer>

<unsigned-integer> ::= {<digit>}+

# ------------------------ Symbols ------------------------
# These are the basic symbols that can be used in the program

<sign> ::= +
         | -

<alpha-num> ::= <digit> 
              | <letter>

<digit> ::= 0
          | 1
          | 2
          | 3
          | 4
          | 5
          | 6
          | 7
          | 8
          | 9

<letter> ::= A
           | B
           | C
           | D
           | E
           | F
           | G
           | H
           | I
           | J
           | K
           | L
           | M
           | N
           | O
           | P
           | Q
           | R
           | S
           | T
           | U
           | V
           | W
           | X
           | Y
           | Z
           | a
           | b
           | c
           | d
           | e
           | f
           | g
           | h
           | i
           | j
           | k
           | l
           | m
           | n
           | o
           | p
           | q
           | r
           | s
           | t
           | u
           | v
           | w
           | x
           | y
           | z