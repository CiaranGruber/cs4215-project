// ------------------------ Function definition ------------------------

<translation-unit> ::= <external-declaration>
                     | <translation-unit> <external-declaration>

<external-declaration> ::= <function-definition>
                         | <declaration>

// In other words - Declaration specifiers is type, declarator is name and params, declaration list is x and compound
// statement is the main body
<function-definition> ::= <declaration-specifiers> <declarator> {<declaration-list>}? <compound-statement>

// ------------------------ Statements ------------------------

// The default statement
<statement> ::= <labelled-statement>
              | <compound-statement>
              | <expression-statement>
              | <selection-statement>
              | <iteration-statement>
              | <jump-statement>

// Labelled statements - used for goto and other things
<labelled-statement> ::= <identifier> : <statement>
                      | case <constant-expression> : <statement>
                      | default : <statement>

// Block statements
<compound-statement> ::= { {<block-item-list>}? }

<block-item-list> ::= <block-item>
                    | <block-item-list> <block-item>

<block-item> ::= <declaration>
               | <statement>

// Standard expression statement
<expression-statement> ::= {<expression>}? ;

// Selection statement
<selection-statement> ::= if ( <expression> ) <statement>
                        | if ( <expression> ) <statement> else <statement>
                        | switch ( <expression> ) <statement>

// Iteration statements
<iteration-statement> ::= while ( <expression> ) <statement>
                        | do ( <statement> ) while ( <expression> ) ;
                        | for ( {<expression>}? ; {<expression>}? ; {<expression>}? ) <statement>
                        | for ( <declaration> {<expression>}? ; {<expression>}? ) <statement> // Standard for loop (uses declaration)

// Jump statements
<jump-statement> ::= goto <identifier> ;  // Goes to a label within the enclosing function
                   | continue ;
                   | break ;
                   | return {<expression>}? ;

// ------------------------ Initialisers ------------------------

<initialiser> ::= <assignment-expression> // An expression to initialise to
                | { <initialiser-list> } // Used for initialising arrays and structs
                | { <initialiser-list> , } // The initialiser list with a trailing comma

<initialiser-list> ::= {<designation>}? <initialiser>
                     | <initialiser-list> , {<designation>}? <initialiser>

<designation> ::= <designator-list> =

<designator-list> ::= <designator> // Single designator
                    | <designator-list> <designator> // Used for multi-dimensional array, etc

<designator> ::= [ <constant-expression> ] // Value has array type
               | '.' <identifier> // Value is a structure or union

// Allows for the initialisation of multiple values of the same type. Eg. int x = 2, y = 3;
<init-declarator-list> ::= <init-declarator>
                         | <init-declarator-list> , <init-declarator>

// Describes the standard way to initialise a value
<init-declarator> ::= <declarator>
                    | <declarator> = <initialiser>

// ------------------------ Declarations ------------------------
// Used when referencing an existing variable, etc

<declaration-list> ::= <declaration>
                    | <declaration-list> <declaration>

// Contains a set of specifiers and the initialiser
<declaration> ::= <declaration-specifiers> {<init-declarator-list>}? ;

// Creates a set of declaration specifiers
<declaration-specifiers> ::= <storage-class-specifier> {<declaration-specifiers>}?
                           | <type-specifier> {<declaration-specifiers>}?
                           | <type-qualifier> {<declaration-specifiers>}?
                           | <function-specifier> {<declaration-specifiers>}?

// A decorated name/identifier
<declarator> ::= {<pointer>}? <direct-declarator>

// Decorates an identifier with the relevant parts
<direct-declarator> ::= <identifier> // Identifier by itself - base version
                      | ( <declarator> ) // Is identical to unparenthesised although binding may be altered
                      | <direct-declarator> [ {<type-qualifier-list>}? {<assignment-expression>}? ] // Array declaration with expression
                      | <direct-declarator> [ static {<type-qualifier-list>}? <assignment-expression> ] // Array declaration with static type
                      | <direct-declarator> [ <type-qualifier-list> static <assignment-expression> ] // Array declaration with static expression
                      | <direct-declarator> [ <type-qualifier-list> * ] // Variable-length array - only used within declarations of functions
                      | <direct-declarator> ( <parameter-type-list> ) // Used for defining functions
                      | <direct-declarator> ( {<identifier-list>}? ) // 

<pointer> ::= * {<type-qualifier-list>}?
            | * {<type-qualifier-list>}? <pointer>

<parameter-type-list> ::= <parameter-list> // Used for standard parameter list
                        | <parameter-list> , ... // Used for functions with and unspecified argument value at the end 

// Standard list of parameters
<parameter-list> ::= <parameter-declaration>
                   | <parameter-list> , <parameter-declaration>

// Parameters
<parameter-declaration> ::= <declaration-specifiers> <declarator>
                          | <declaration-specifiers> {<abstract-declarator>}? // Used for function prototypes

// Declares the variable types without need for an identifier
<abstract-declarator> ::= <pointer>
                        | {<pointer>}? <direct-abstract-declarator>

<direct-abstract-declarator> ::= ( <abstract-declarator> )
                               | <direct-abstract-declarator> [ {<type-qualifier-list>}? {<assignment-expression>}? ] // Array declaration with expression
                               | <direct-abstract-declarator> [ static {<type-qualifier-list>}? <assignment-expression> ] // Array declaration with static type
                               | <direct-abstract-declarator> [ <type-qualifier-list> static <assignment-expression> ] // Array declaration with static expression
                               | <direct-abstract-declarator> [ <type-qualifier-list> * ] // Variable length array - only used within declarations of functions
                               | <direct-abstract-declarator> ( <parameter-type-list> ) // Used for defining functions

// ------------------------ Type specification ------------------------
// These specify the actual type

// Specifies the way that types are to be stored
<storage-class-specifier> ::= typedef // Defines a new type
                            | extern // Specifies that it is already defined elsewhere in the program (but not in the current file)
                            | static // Retains the value within statically allocated memory rather than dynamic memory
                            | auto // Does nothing
                            | register // Access to the object should be as fast as possible

// Specifies the actual types of values
<type-specifier> ::= void
                   | char
                   | short
                   | int
                   | long
                   | float
                   | double
                   | signed
                   | unsigned
                   | _Bool
                   | <struct-or-union-specifier>
                   | <enum-specifier>
                   | <typedef-name>

<type-qualifier-list> ::= <type-qualifier>
                        | <type-qualifier-list> <type-qualifier>

// Specifies what to do when setting values
<type-qualifier> ::= const // Specifies that the thing to the right will not change
                   | volatile // Specifies that variables must be read from memory every time

// Specifies a type name
<type-name> ::= <specifier-qualifier-list> {<abstract-declarator>}?

// Combines a set of type qualifiers and type specifiers
<specifier-qualifier-list> ::= <type-specifier> {<specifier-qualifier-list>}?
                             | <type-qualifier> {<specifier-qualifier-list>}?

// ------------------------ Function specification ------------------------

// Refines a function further
<function-specifier> ::= inline // Used if the function only contains a return (equivalent of a tail call)

// ------------------------ Struct and Union specification ------------------------

// Declares a structure or union
<struct-or-union-specifier> ::= <struct-or-union> <identifier> { <struct-declaration-list> } // Declares and defines a struct with an identifier
                              | <struct-or-union> { <struct-declaration-list> } // Defines an anonymous struct 
                              | <struct-or-union> <identifier> // Declares the struct without defining it

// Defines a list of attributes within the struct
<struct-declaration-list> ::= <struct-declaration>
                            | <struct-declaration-list> <struct-declaration>

// Defines an attribute in the struct (Note: Can be a list of values or just a qualified type)
<struct-declaration> ::= <specifier-qualifier-list> {<struct-declarator-list>}? ;

// Contains a list of names with the same type
<struct-declarator-list> ::= {<struct-declarator-list> ,}? <struct-declarator>

// Used to declare values in a struct
<struct-declarator> ::= <declarator> // Used for anonymous values
                      | {<declarator>}? : <constant-expression> // Used for default values

// The actual struct or union keywords
<struct-or-union> ::= struct
                    | union

// ------------------------ Enum specification ------------------------

// Declares an enumeration
<enum-specifier> ::= enum {<identifier>}? { <enumerator-list> } // Declares and defines an enumeration
                   | enum {<identifier>}? { <enumerator-list> , } // Declares and defines an enumeration with a spare comma
                   | enum <identifier> // Declares an enumeration without defining it

// Defines a list of enumerators
<enumerator-list> ::= <enumerator>
                    | <enumerator-list> , <enumerator>

// Defines an enumeration constant
<enumerator> ::= <enumeration-constant> // Defines an enumeration constant without a value
               | <enumeration-constant> = <constant-expression> // Defines an enumeration constant with a value

// ------------------------ Expressions ------------------------
// These are things that return a value

// Can be calculated at compile-time for improved optimisation.
// Must not contain assignment, increment, decrement, function-call, or comma operators
<constant-expression> ::= <conditional-expression>

// The base type of expression (excluding comma-expression)
<expression> ::= <comma-expression>

// This evaluates the first value and then returns the second value. For example (t=2, t+2) will return 4 if t is declared
<comma-expression> ::= <assignment-expression>
                     | <expression> , <assignment-expression>

// Assigns a value and returns the set value
// Note: <unary-expression> must be a modifiable lvalue
<assignment-expression> ::= <conditional-expression>
                          | <unary-expression> = <assignment-expression>
                          | <unary-expression> <assignment-operator-shorthand> <assignment-expression>

// Each operator can be converted from 'E1 op E2' to 'E1 = E1 op E2'
<assignment-operator-shorthand> ::= *=
                                  | /=
                                  | %=
                                  | +=
                                  | <<=
                                  | >>=
                                  | &=
                                  | ^=
                                  | |=

// Runs conditional expressions returns <expression> if <logical-or-expression> is true, else <conditional-expression>
// Note: The way its set prevents the following: true ? 1 : a = 2;
// Additionally, this will always return a value. It cannot return an lvalue
<conditional-expression> ::= <logical-or-expression>
                           | <logical-or-expression> ? <expression> : <conditional-expression>

// Performs logical or on both values
<logical-or-expression> ::= <logical-and-expression>
                          | <logical-or-expression> && <logical-and-expression>

// Performs logical and on both values
<logical-and-expression> ::= <inclusive-or-expression>
                           | <logical-and-expression> && <inclusive-or-expression>

// Performs bitwise inclusive or on two values
<inclusive-or-expression> ::= <exclusive-or-expression>
                            | <inclusive-or-expression> | <exclusive-or-expression> 

// Performs bitwise exclusive or on two values
<exclusive-or-expression> ::= <and-expression>
                            | <exclusive-or-expression> ^ <and-expression> 

// Performs bitwise AND on two values
<and-expression> ::= <equality-expression>
                   | <and-expression> & <equality-expression>

// This is equality testing
<equality-expression> ::= <relational-expression>
                        | <equality-expression> <equality-operators> <relational-expression>

<equality-operators> ::= == // Tests equality
                       | != // Tests inequality

// This is basically greater than or less than
<relational-expression> ::= <shift-expression>
                          | <relational-expression> <relational-operators> <shift-expression>

<relational-operators> ::= >
                         | <
                         | >=
                         | <=

// These are the bitwise shift operators
<shift-expression> ::= <additive-expression>
                     | <shift-expression> <shift-operators> <additive-expression> // Shifts the first value by the second value

<shift-operators> ::= >> // Shifts right
                    | << // Shifts left

// These are the additive operators
<additive-expression> ::= <multiplicative-expression>
                        | <additive-expression> <additive-operators> <multiplicative-expression>

<additive-operators> ::= +
                       | -

// Runs multiplicative operations from left to right
<multiplicative-expression> ::= <cast-expression>
                              | <multiplicative-expression> <multiplicative-operators> <cast-expression>

<multiplicative-operators> ::= *
                             | /
                             | %

<cast-expression> ::= <unary-expression>
                    | <cast-expression> // Casts the value to the given type

<unary-expression> ::= <postfix-expression>
                     | ++ <unary-expression> // Increments value and returns incremented lvalue (++E1 = E += 1)
                     | -- <unary-expression> // Decrements value and returns incremented lvalue (--E1 = E -= 1)
                     | <unary-operator> <cast-expression> // Runs the various operators on the given expression. Note allows - (int) a
                     | sizeof <unary-expression> // Allows sizeof to work without needing function. Note 'sizeofa' must not compile
                     | sizeof ( <type-name> ) // Returns the size in bytes of a type (Note: sizeof(a) where a is a variable is solved
                                              // by primary-expression)

<unary-operator> ::= & // Gets the reference of the lvalue
                   | * // Dereferences a given lvalue
                   | + // Does nothing
                   | - // Flips the sign of the given value
                   | ~ // Flips the individual bits for the value
                   | ! // Flips a boolean value

<postfix-expression> ::= <primary-expression>
                       | <postfix-expression> [ <expression> ]  // Access an array element (E1[E2] = *(E1+E2))
                       | <postfix-expression> ( ) // Evaluate function without params
                       | <postfix-expression> ( <argument-expression-list> ) // Evaluate function with params
                       | <postfix-expression> . <identifier> // Gets a value in a struct
                       | <postfix-expression> -> <identifier> // Dereferences a struct and gets the value (E1->E2 = (*E1).E2)
                       | <postfix-expression> ++ // Increments value but returns original
                       | <postfix-expression> -- // Decrements value but returns original

<primary-expression> ::= <identifier>
                       | <constant>
                       | <string>
                       | ( <expression> ) // Requires anything of greater hierarchy to be wrapped in brackets (Ie. can't have ++ (int) a)

// ------------------------ Miscellaneous ------------------------

// Identifies a typedef name
<typedef-name> ::= <identifier>

// ------------------------ Basic Lexical Elements ------------------------

// The minimal lexical element of the language
<token> ::= <keyword>
          | <identifier>
          | <constant>
          | <string-literal>
          | <punctuator>

// Used as a token that is preprocessed (Eg. Added to VM as val:)
<preprocessing-token> ::= <header-name>
                        | <identifier>
                        | <pp-number>
                        | <character-constant>
                        | <string-literal>
                        | <punctuator>
                        | 

// ------------------------ Keywords ------------------------

// These are case-sensitive and cannot be used for anything such as identifiers, etc
// Note: Whether these are implemented, should not change if they are accepted as identifiers in order to prevent compilation errors
<keyword> ::= auto
            | break
            | case
            | char
            | const
            | continue
            | default
            | do
            | double
            | else
            | enum
            | extern
            | float
            | for
            | goto
            | if
            | inline
            | int
            | long
            | register
            | restrict
            | return
            | short
            | signed
            | sizeof
            | static
            | struct
            | switch
            | typedef
            | union
            | unsigned
            | void
            | volatile
            | while
            | _Alignas
            | _Alignof
            | _Atomic
            | _Bool
            | _Complex
            | _Generic
            | _Imaginary
            | _Noreturn
            | _Static_assert
            | _Thread_local

// ------------------------ Identifiers ------------------------

// A list of identifiers
<identifier-list> ::= <identifier>
                    | <identifier-list> , <identifier>

// These are the variable names
<identifier> ::= <identifier-nondigit>
               | <identifier> <identifier-nondigit>
               | <identifier> <digit>

// Parts of the identifier that are non digits
<identifier-nondigit> ::= <nondigit>
                        | <universal-character-name>

// ------------------------ Universal Character Names ------------------------

<universal-character-name> ::= \u <hex-quad>
                             | \U <hex-quad> <hex-quad>

<hex-quad> ::= <hexadecimal-digit> <hexadecimal-digit> <hexadecimal-digit> <hexadecimal-digit>

// ------------------------ Constants ------------------------
// These are the available constants and their definitions
// They are typically built of types of symbols

<constant> ::= <integer-constant>
             | <floating-constant>
             | <enumeration-constant>
             | <character-constant>

// ------------------------ Integer Constants ------------------------

<integer-constant> ::= <decimal-constant> {<integer-suffix>}? // Decimal integer
                     | <octal-constant> {<integer-suffix>}? // Octal integer
                     | <hexadecimal-constant> {<integer-suffix>}? // Hexadecimal integer

// Used to represent the standard decimals - Must start with not 0
<decimal-constant> ::= <non-zero-digit>
                     | <decimal-constant> <digit>

// Used to represent an octal number - Must start with 0
<octal-constant> ::= 0
                   | <octal-constant> <octal-digit>

// Used to represent hexadecimal constants, used mainly for pointers - Must start with the prefix and at least one digit
<hexadecimal-constant> ::= <hexadecimal-prefix> <hexadecimal-digit>
                         | <hexadecimal-constant> <hexadecimal-digit>

<integer-suffix> ::= <unsigned-suffix> {<long-suffix>}? // Allows unsigned potentially double-long integers
                   | <unsigned-suffix> {<long-long-suffix>}? // Allows unsigned potentially double-long integers
                   | <long-suffix> {<unsigned-suffix>}? // Allows long potentially unsigned integers
                   | <long-long-suffix> {<unsigned-suffix>}? // // Allows double-long potentially unsigned integers

// Specifies that a given integer is unsigned
<unsigned-suffix> ::= u
                    | U

// Specifies that a given integer is a long value
<long-suffix> ::= l
                | L

// Specifies that a given integer is a double-long value
<long-long-suffix> ::= ll
                     | LL

// ------------------------ Floating Constants ------------------------
// Note: Floating constants are doubles unless specified by a suffix

<floating-constant> ::= <decimal-floating-constant>
                      | <hexadecimal-floating-constant>

// Floating-point numbers represented with a decimal format
<decimal-floating-constant> ::= <fractional-constant> {<exponent-part>}? {<floating-suffix>}? // Allows standard floats
                              | <digit-sequence> <exponent-part> {<floating-suffix>}? // Allows floats with exponent

// Floating-point numbers represented with a hexadecimal format
<hexadecimal-floating-constant> ::= <hexadecimal-prefix> <hexadecimal-fractional-constant> <binary-exponent-part> {<floating-suffix>}?
                                  | <hexadecimal-prefix> <hexadecimal-digit-sequence> <binary-exponent-part> {<floating-suffix>}?

// The main part of the decimal number. Ie '23.2' in '23.2e2 f L'
<fractional-constant> ::= {<digit-sequence>}? . <digit-sequence> // Allows numbers such as .232 or 23.24
                        | <digit-sequence> . // Allows numbers such as 23. to be a double

// The exponent part of a floating-point decimal number
<exponent-part> ::= e {<sign>}? <digit-sequence>
                  | E {<sign>}? <digit-sequence>

// The main part of the hexadecimal number. Ie 'e.f21' in 'e.f21p21'
<hexadecimal-fractional-constant> ::= {<hexadecimal-digit-sequence>}? . <hexadecimal-digit-sequence>

// The exponent part of a floating-point hexadecimal number. Note: Means exponents in hexadecimal are not hex
<binary-exponent-part> ::= p {<sign>}? <digit-sequence>
                         | P {<sign>}? <digit-sequence>

// The suffix used for floating point numbers
<floating-suffix> ::= f // Specifies that it should be a float instead of a double
                    | F // Same as f
                    | l // Specifies the given double is represented with a float (and so more precise)
                    | L // Same as l

// ------------------------ Enumeration Constants ------------------------

// The enumeration constant
<enumeration-constant> ::= <identifier>

// ------------------------ Character Constants ------------------------

// Specifies the format for character constants
// Note: Other versions are primarily used to manage how hexadecimal escape sequences represent values
<character-constant> ::= ' <c-char-sequence> ' // Represents octal/hex escape sequences as unsigned char
                       | L' <c-char-sequence> ' // Represents octal/hex escape sequences as wchar_t
                       | u' <c-char-sequence> ' // Represents octal/hex escape sequences as char16_t
                       | U' <c-char-sequence> ' // Represents octal/hex escape sequences as char32_t

// ------------------------ String Constants ------------------------

// Specifies the format for string literals
<string-literal> ::= {<encoding-prefix>}? " {<s-char-sequence>}? "

// The encoding prefix for the string literal
<encoding-prefix> ::= u8
                    | u
                    | U
                    | L

// ------------------------ Punctuators ------------------------

// Should not be trimmed with sublanguage in order to avoid invalid C programs running
<punctuator> ::= [
               | ]
               | (
               | )
               | {
               | }
               | .
               | ->
               | ++
               | --
               | &
               | *
               | +
               | -
               | ~
               | !
               | /
               | %
               | <<
               | >>
               | <
               | >
               | <=
               | >=
               | ==
               | !=
               | ^
               | |
               | &&
               | ||
               | ?
               | :
               | ;
               | ...
               | =
               | *=
               | /=
               | %=
               | +=
               | -=
               | <<=
               | >>=
               | &=
               | ^=
               | |=
               | ,
               | //
               | ////
               | <:
               | :>
               | <%
               | %>
               | %:
               | %:%:

// ------------------------ Header names ------------------------

// Represents header names when doing //import <header.h>
<header-name> ::= < <h-char-sequence> >
                | " <q-char-sequence> "

// ------------------------ Preprocessing Numbers ------------------------

// See C Spec 6.10.1 about conditional inclusion for use case 
<pp-number> ::= <digit>
              | . <digit>
              | <pp-number> <digit>
              | <pp-number> <identifier-nondigit>
              | <pp-number> e <sign>
              | <pp-number> E <sign>
              | <pp-number> p <sign>
              | <pp-number> P <sign>
              | <pp-number> .

// ------------------------ Basic constant representations ------------------------

// A sequence of digits
<digit-sequence> ::= <digit>
                   | <digit-sequence> <digit>

// A sequence of hexadecimal digits
<hexadecimal-digit-sequence> ::= <hexadecimal-digit>
                               | <hexadecimal-digit-sequence> <hexadecimal-digit>

// Represents a sequence of characters in c
<c-char-sequence> ::= <c-char>
                    | <c-char-sequence> <c-char>

// Represents a single char character - Should represent all characters in source character set excluding ', \, and \n
<c-char> ::= // All characters described above
           | <escape-sequence>

// The character sequence for a string
<s-char-sequence> ::= <s-char>
                    | <s-char-sequence> <s-char>

// Represents a single string character - Should represent all characters in source character set excluding ", \, and \n
<s-char> ::= // All characters described above 
           | <escape-sequence>

// The character sequence for a header with global reference
<h-char-sequence> ::= <h-char>
                    | <h-char-sequence> <h-char>

// Represents a single header character - Should represent all characters in source character set excluding \n, and >
<h-char> ::= // All characters described above 
           | <escape-sequence>

// The character sequence for a header with local reference
<q-char-sequence> ::= <q-char>
                    | <q-char-sequence> <q-char>

// Represents a single header character - Should represent all characters in source character set excluding \n, and "
<q-char> ::= // All characters described above 
           | <escape-sequence>

// A typical escape sequence in C strings or characters
<escape-sequence> ::= <simple-escape-sequence> // The standard escape sequence
                    | <octal-escape-sequence> // An escape sequence with an octal number
                    | <hexadecimal-escape-sequence> // A hexadecimal escape sequence

// ------------------------------------------------------ REMOVE ADDITIONAL CHARACTERS FOR CHAR/STRING QUOTES 
// Represents a standard escape sequence
<simple-escape-sequence> ::= \'
'                           | \"
"                           | \?
                           | \\
                           | \a
                           | \b
                           | \f
                           | \n
                           | \r
                           | \t
                           | \v

// Represents an octal escape sequence
<octal-escape-sequence> ::= \ <octal-digit>
                          | \ <octal-digit> <octal-digit>
                          | \ <octal-digit> <octal-digit>

// Represents a hexadecimal escape sequence
<hexadecimal-escape-sequence> ::= \x <hexadecimal-digit>
                                | <hexadecimal-escape-sequence> <hexadecimal-digit>

// ------------------------ Basic Symbols ------------------------
// These are the basic symbols that can be used in the program

<sign> ::= +
         | -

// The prefix required for hexadecimal integers
<hexadecimal-prefix> ::= 0x

<nonzero-digit> ::= 1
                  | 2
                  | 3
                  | 4
                  | 5
                  | 6
                  | 7
                  | 8
                  | 9

<octal-digit> ::= 0
                | 1
                | 2
                | 3
                | 4
                | 5
                | 6
                | 7

<hexadecimal-digit> ::= 0
                      | 1
                      | 2
                      | 3
                      | 4
                      | 5
                      | 6
                      | 7
                      | 8
                      | 9
                      | a
                      | b
                      | c
                      | d
                      | e
                      | f
                      | A
                      | B
                      | C
                      | D
                      | E
                      | F

<nondigit> ::= _
             | A
             | B
             | C
             | D
             | E
             | F
             | G
             | H
             | I
             | J
             | K
             | L
             | M
             | N
             | O
             | P
             | Q
             | R
             | S
             | T
             | U
             | V
             | W
             | X
             | Y
             | Z
             | a
             | b
             | c
             | d
             | e
             | f
             | g
             | h
             | i
             | j
             | k
             | l
             | m
             | n
             | o
             | p
             | q
             | r
             | s
             | t
             | u
             | v
             | w
             | x
             | y
             | z

<digit> ::= 0
          | 1
          | 2
          | 3
          | 4
          | 5
          | 6
          | 7
          | 8
          | 9














<alpha-num> ::= <digit> 
              | <letter>

<digit> ::= 0
          | 1
          | 2
          | 3
          | 4
          | 5
          | 6
          | 7
          | 8
          | 9

<letter> ::= A
           | B
           | C
           | D
           | E
           | F
           | G
           | H
           | I
           | J
           | K
           | L
           | M
           | N
           | O
           | P
           | Q
           | R
           | S
           | T
           | U
           | V
           | W
           | X
           | Y
           | Z
           | a
           | b
           | c
           | d
           | e
           | f
           | g
           | h
           | i
           | j
           | k
           | l
           | m
           | n
           | o
           | p
           | q
           | r
           | s
           | t
           | u
           | v
           | w
           | x
           | y
           | z